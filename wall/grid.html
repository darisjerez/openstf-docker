<!DOCTYPE html>
<html>
<head>
  <title>Device Wall</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      background: #111;
      font-family: sans-serif;
    }

    .header {
      padding: 8px 12px;
      background: #1a1a1a;
      color: #888;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header .count { color: #0f0; }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 8px;
      padding: 8px;
    }

    .device {
      background: #000;
      border: 1px solid #333;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
    }

    .label {
      color: #0f0;
      font-size: 12px;
      background: #1a1a1a;
      padding: 4px 6px;
    }

    .status {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0,0,0,0.6);
    }

    .status.connecting { color: #ff0; }
    .status.live { color: #0f0; }
    .status.error { color: #f00; }
    .status.paused { color: #888; }

    .controls {
      display: flex;
      justify-content: flex-end;
      padding: 4px;
      background: #1a1a1a;
    }

    .controls button {
      background: #333;
      color: #ccc;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 4px 14px;
      font-size: 12px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #444;
    }

    .spotify-toggle {
      background: #333;
      color: #ccc;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .spotify-toggle:hover {
      background: #444;
    }

    .spotify-toggle.active {
      background: #1DB954;
      color: #fff;
      border-color: #1DB954;
    }

    .spotify-toggle.healing {
      animation: pulse-green 1s ease-in-out infinite;
    }

    .spotify-countdown {
      font-size: 10px;
      display: block;
      margin-top: 1px;
    }

    .duration-picker {
      position: absolute;
      bottom: 100%;
      right: 0;
      margin-bottom: 4px;
      background: #222;
      border: 1px solid #555;
      border-radius: 6px;
      overflow: hidden;
      z-index: 20;
      min-width: 130px;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.5);
    }

    .duration-option {
      padding: 8px 14px;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
    }

    .duration-option:hover {
      background: #333;
    }

    .duration-option.selected {
      color: #1DB954;
    }

    @keyframes pulse-green {
      0%, 100% { background: #1DB954; }
      50% { background: #15843d; }
    }

    .setup {
      color: #ccc;
      max-width: 500px;
      margin: 80px auto;
      text-align: center;
      line-height: 1.6;
    }

    .setup code {
      background: #222;
      padding: 2px 6px;
      border-radius: 3px;
      color: #0f0;
    }

    @media (max-width: 600px) {
      .grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }

      .controls button, .spotify-toggle {
        padding: 8px 16px;
      }

      .label {
        font-size: 13px;
      }

      .status {
        font-size: 11px;
      }

      .duration-picker {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
        border-radius: 12px 12px 0 0;
        min-width: auto;
      }

      .duration-option {
        padding: 14px 20px;
        font-size: 16px;
        text-align: center;
        border-bottom: 1px solid #333;
      }
    }
  </style>
</head>
<body>

<!--
  SETUP: Generate an STF access token:
  1. Log into STF web UI (http://SERVER_IP:7100)
  2. Go to Settings > Keys > Add a new key
  3. Copy the token and paste it below

  NOTE: Devices claimed by the wall will show as "in use" in STF.
  Use a dedicated user (e.g. wall@farm) to avoid conflicts.
-->

<div class="header">
  <span>Device Wall</span>
  <span id="status-bar">loading...</span>
</div>

<div class="grid" id="grid"></div>

<div class="setup" id="setup" style="display:none">
  <p>Paste your STF access token below to enable the device wall.</p>
  <p>Generate one at <code>STF Settings &gt; Keys</code></p>
  <p><input id="token-input" type="text" placeholder="STF access token" style="width:100%;padding:8px;font-size:14px;background:#222;color:#fff;border:1px solid #444;border-radius:4px"></p>
  <p><button onclick="saveToken()" style="padding:8px 24px;font-size:14px;cursor:pointer">Save &amp; Connect</button></p>
</div>

<script>
const TOKEN_KEY = "stf_wall_token"
const DURATION_KEY = "stf_healer_duration"

const DURATION_OPTIONS = [
  { label: '15 minutes', ms: 15 * 60 * 1000 },
  { label: '1 hour', ms: 60 * 60 * 1000 },
  { label: '6 hours', ms: 6 * 60 * 60 * 1000 },
  { label: '12 hours', ms: 12 * 60 * 60 * 1000 },
  { label: 'Infinite', ms: 0 }
]

function getLastDuration() {
  const v = parseInt(localStorage.getItem(DURATION_KEY), 10)
  return isNaN(v) ? 0 : v
}

function saveLastDuration(ms) {
  localStorage.setItem(DURATION_KEY, String(ms))
}

function formatRemaining(ms) {
  if (ms <= 0) return ''
  const s = Math.floor(ms / 1000)
  const h = Math.floor(s / 3600)
  const m = Math.floor((s % 3600) / 60)
  const sec = s % 60
  if (h > 0) return h + 'h ' + m + 'm'
  if (m > 0) return m + 'm ' + sec + 's'
  return sec + 's'
}

function getToken() {
  return localStorage.getItem(TOKEN_KEY) || ""
}

function saveToken() {
  const val = document.getElementById("token-input").value.trim()
  if (val) {
    localStorage.setItem(TOKEN_KEY, val)
    location.reload()
  }
}

async function api(method, path, body) {
  const headers = { "Content-Type": "application/json" }
  const token = getToken()
  if (token) headers["Authorization"] = "Bearer " + token
  const opts = { method, headers }
  if (body) opts.body = JSON.stringify(body)
  const res = await fetch(path, opts)
  return res.json()
}

function setStatus(text) {
  document.getElementById("status-bar").innerHTML = text
}

function createDeviceEl(serial, model) {
  const container = document.createElement("div")
  container.className = "device"
  container.id = "dev-" + serial

  const canvas = document.createElement("canvas")
  canvas.width = 270
  canvas.height = 480

  const label = document.createElement("div")
  label.className = "label"
  label.innerText = model ? `${model} (${serial})` : serial

  const status = document.createElement("div")
  status.className = "status connecting"
  status.innerText = "connecting..."

  const controls = document.createElement("div")
  controls.className = "controls"
  const btn = document.createElement("button")
  btn.innerText = "Stop"
  controls.appendChild(btn)

  const spotifyWrap = document.createElement("span")
  spotifyWrap.style.position = "relative"
  spotifyWrap.style.display = "inline-block"
  spotifyWrap.style.marginLeft = "4px"

  const spotifyBtn = document.createElement("button")
  spotifyBtn.className = "spotify-toggle"
  spotifyBtn.innerHTML = "\u266B Spotify"
  spotifyBtn.onclick = (e) => { e.stopPropagation(); toggleSpotify(serial, spotifyBtn, spotifyWrap) }

  spotifyWrap.appendChild(spotifyBtn)
  controls.appendChild(spotifyWrap)

  container.appendChild(canvas)
  container.appendChild(label)
  container.appendChild(status)
  container.appendChild(controls)
  document.getElementById("grid").appendChild(container)

  return { canvas, status, btn, spotifyBtn }
}

async function claimDevice(serial) {
  const token = getToken()

  // Try to claim — 403 is OK if device is already in our group
  await fetch("/api/v1/user/devices/" + serial, {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ serial: serial, timeout: 900000 })
  })

  // Poll for display URL with backoff (200ms → 400ms → 800ms → 2000ms max)
  let delay = 200
  for (let i = 0; i < 15; i++) {
    await new Promise(r => setTimeout(r, delay))
    delay = Math.min(delay * 2, 2000)

    const res = await fetch("/api/v1/user/devices/" + serial, {
      headers: { "Authorization": "Bearer " + token }
    })

    // 403 on GET means a different user owns this device
    if (res.status === 403) {
      throw new Error("in use by another user")
    }

    if (res.ok) {
      const data = await res.json()
      const dev = data.device
      if (dev && dev.display && dev.display.url) {
        return dev.display.url
      }
    }
  }
  return null
}

function connectStream(wsUrl, el) {
  const parsed = new URL(wsUrl)
  const proxiedUrl = `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/screen/${parsed.port}`

  let ws = null
  let stopped = false

  function start() {
    ws = new WebSocket(proxiedUrl)
    ws.binaryType = "arraybuffer"

    const ctx = el.canvas.getContext("2d")
    let gotBanner = false
    let pendingFrame = null
    let rendering = false
    let canvasW = 0, canvasH = 0

    function renderFrame() {
      if (!pendingFrame) { rendering = false; return }
      rendering = true
      const data = pendingFrame
      pendingFrame = null
      createImageBitmap(new Blob([data], { type: "image/jpeg" })).then(bmp => {
        if (bmp.width !== canvasW || bmp.height !== canvasH) {
          canvasW = el.canvas.width = bmp.width
          canvasH = el.canvas.height = bmp.height
        }
        ctx.drawImage(bmp, 0, 0)
        bmp.close()
        renderFrame()
      }).catch(() => { rendering = false })
    }

    ws.onopen = () => {
      ws.send("size 480x800")
      ws.send("on")
      el.status.className = "status live"
      el.status.innerText = "live"
    }

    ws.onmessage = event => {
      if (typeof event.data === "string") {
        if (event.data === "ping") ws.send("pong")
        return
      }

      if (!gotBanner) {
        gotBanner = true
        if (event.data.byteLength === 24) return
      }

      pendingFrame = event.data
      if (!rendering) renderFrame()
    }

    ws.onerror = () => {
      el.status.className = "status error"
      el.status.innerText = "stream error"
    }

    ws.onclose = () => {
      if (!stopped) {
        el.status.className = "status error"
        el.status.innerText = "reconnecting..."
        setTimeout(start, 5000)
      }
    }
  }

  el.btn.onclick = () => {
    if (stopped) {
      stopped = false
      el.btn.innerText = "Stop"
      start()
    } else {
      stopped = true
      el.btn.innerText = "Resume"
      el.status.className = "status paused"
      el.status.innerText = "paused"
      if (ws) ws.close()
    }
  }

  start()
}

async function startDevice(serial, model) {
  const el = createDeviceEl(serial, model)

  try {
    const displayUrl = await claimDevice(serial)
    if (!displayUrl) {
      el.status.className = "status error"
      el.status.innerText = "no stream"
      console.warn(serial, "- no display URL after claiming")
      return
    }
    console.log(serial, "stream at", displayUrl)
    connectStream(displayUrl, el)
  } catch (err) {
    console.error(serial, "claim failed:", err)
    el.status.className = "status error"
    el.status.innerText = err.message === "in use by another user" ? "in use" : "claim failed"
  }
}

function closePickers() {
  document.querySelectorAll('.duration-picker').forEach(p => p.remove())
}

function showDurationPicker(serial, btn, wrap) {
  closePickers()
  const picker = document.createElement('div')
  picker.className = 'duration-picker'
  const lastDuration = getLastDuration()

  DURATION_OPTIONS.forEach(opt => {
    const item = document.createElement('div')
    item.className = 'duration-option'
    if (opt.ms === lastDuration) item.classList.add('selected')
    item.textContent = opt.label
    item.onclick = async (e) => {
      e.stopPropagation()
      picker.remove()
      saveLastDuration(opt.ms)
      try {
        const res = await fetch("/healer/api/watch/" + serial, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ duration: opt.ms })
        })
        const data = await res.json()
        btn.classList.add("active")
        if (data.expiresAt) {
          btn.dataset.expiresAt = data.expiresAt
        } else {
          delete btn.dataset.expiresAt
        }
        updateCountdownText(btn)
      } catch (err) {
        console.error("healer start failed:", err)
      }
    }
    picker.appendChild(item)
  })

  wrap.appendChild(picker)
}

async function toggleSpotify(serial, btn, wrap) {
  const isActive = btn.classList.contains("active")
  try {
    if (isActive) {
      closePickers()
      await fetch("/healer/api/watch/" + serial, { method: "DELETE" })
      btn.classList.remove("active", "healing")
      delete btn.dataset.expiresAt
      updateCountdownText(btn)
    } else {
      showDurationPicker(serial, btn, wrap)
    }
  } catch (err) {
    console.error("healer toggle failed:", err)
  }
}

function updateCountdownText(btn) {
  let countdownEl = btn.querySelector('.spotify-countdown')
  const expiresAt = parseInt(btn.dataset.expiresAt, 10)
  if (!expiresAt || isNaN(expiresAt)) {
    if (countdownEl) countdownEl.remove()
    return
  }
  const remaining = expiresAt - Date.now()
  if (remaining <= 0) {
    btn.classList.remove("active", "healing")
    delete btn.dataset.expiresAt
    if (countdownEl) countdownEl.remove()
    return
  }
  if (!countdownEl) {
    countdownEl = document.createElement('span')
    countdownEl.className = 'spotify-countdown'
    btn.appendChild(countdownEl)
  }
  countdownEl.textContent = formatRemaining(remaining)
}

// Tick all countdowns every second
setInterval(() => {
  document.querySelectorAll('.spotify-toggle.active').forEach(btn => {
    updateCountdownText(btn)
  })
}, 1000)

async function syncHealerStatus() {
  try {
    const res = await fetch("/healer/api/status")
    const data = await res.json()
    for (const [serial, state] of Object.entries(data)) {
      const el = document.querySelector("#dev-" + serial + " .spotify-toggle")
      if (el && state.watching) {
        el.classList.add("active")
        if (state.expiresAt) {
          el.dataset.expiresAt = state.expiresAt
        }
        updateCountdownText(el)
      }
    }
  } catch (err) {
    console.warn("healer status unavailable:", err.message)
  }
}

async function init() {
  const token = getToken()
  if (!token) {
    document.getElementById("setup").style.display = "block"
    setStatus("no token configured")
    return
  }

  setStatus("fetching devices...")

  let data
  try {
    data = await api("GET", "/api/v1/devices")
  } catch (err) {
    setStatus('<span style="color:#f00">API error — check token</span>')
    return
  }

  if (!data.devices) {
    setStatus('<span style="color:#f00">invalid response — check token</span>')
    return
  }

  const devices = data.devices.filter(d => d.present)
  setStatus(`<span class="count">${devices.length}</span> devices found — claiming...`)

  // Claim all devices in parallel
  await Promise.all(devices.map(d => startDevice(d.serial, d.model)))

  setStatus(`<span class="count">${devices.length}</span> devices streaming`)

  // Sync Spotify watcher toggle states from healer service
  await syncHealerStatus()
}

// Release devices when leaving the page
window.addEventListener("beforeunload", () => {
  const token = getToken()
  if (!token) return
  // Fire-and-forget release calls
  navigator.sendBeacon && api("GET", "/api/v1/user/devices").then(data => {
    if (data.devices) {
      data.devices.forEach(d => {
        fetch("/api/v1/user/devices/" + d.serial, {
          method: "DELETE",
          headers: {
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json"
          },
          keepalive: true
        })
      })
    }
  })
})

document.addEventListener('click', () => closePickers())

init()
</script>

</body>
</html>
